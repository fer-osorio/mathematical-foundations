/**
 * ============================================================================
 * ELLIPTIC CURVE CRYPTOGRAPHY - CORE IMPLEMENTATION
 *
 * This module implements standard elliptic curves and cryptographic protocols
 * (ECDH, ECDSA) built on top of the mathematical utilities.
 *
 * STANDARD CURVES IMPLEMENTED:
 * - secp256k1: Bitcoin, Ethereum (Koblitz curve)
 * - P-256 (secp256r1): NIST standard, TLS, certificates
 * - Curve25519: Modern, fast, secure (for future implementation)
 *
 * CRYPTOGRAPHIC PROTOCOLS:
 * - ECDH: Elliptic Curve Diffie-Hellman (key exchange)
 * - ECDSA: Elliptic Curve Digital Signature Algorithm
 *
 * SECURITY ASSUMPTIONS:
 * - ECDLP Hardness: Given P and Q = kP, finding k is computationally hard
 * - CDH Hardness: Given P, aP, bP, computing abP is hard
 * - Random Oracle Model: Hash functions behave like random oracles
 *
 * These implementations follow SECG, NIST, and IETF standards.
 * The mathematics is identical to textbook knowledge, but here
 * we must also handle:
 * - Parameter validation (reject malicious inputs)
 * - Side-channel resistance (constant-time operations)
 * - Deterministic nonce generation (RFC 6979)
 *
 * ============================================================================
 */

// ============================================================================
// ELLIPTIC CURVE DEFINITION
// ============================================================================

/**
 * Elliptic Curve over finite field F_p
 *
 * CURVE EQUATION: y² ≡ x³ + ax + b (mod p)
 *
 * PARAMETERS (Domain Parameters):
 * - p: Prime defining the finite field F_p
 * - a, b: Curve coefficients (must satisfy 4a³ + 27b² ≠ 0 mod p)
 * - G: Generator point (base point for scalar multiplication)
 * - n: Order of G (number of points in subgroup generated by G)
 * - h: Cofactor = #E(F_p) / n (usually 1 for prime-order curves)
 *
 * SECURITY REQUIREMENTS:
 * - p should be large prime (≥ 256 bits for 128-bit security)
 * - n should be prime or have large prime factor
 * - Embedding degree should be large (resist MOV attack)
 * - Curve should not be anomalous (p ≠ n)
 */
class EllipticCurve {
    /**
     * @param {String} name - Curve name (e.g., "secp256k1")
     * @param {BigInt} p - Prime field modulus
     * @param {BigInt} a - Curve parameter a
     * @param {BigInt} b - Curve parameter b
     * @param {Object} G - Generator point {x, y}
     * @param {BigInt} n - Order of generator
     * @param {BigInt} h - Cofactor
     */
    constructor(name, p, a, b, G, n, h) {
        this.name = name;
        this.p = p;
        this.a = a;
        this.b = b;
        this.n = n;
        this.h = h;

        // Create generator point
        this.G = new ECMathUtils.Point(G.x, G.y, this);

        // Validate curve on construction
        this.validate();
    }

    /**
     * Validate curve parameters
     *
     * CHECKS:
     * 1. Non-singularity: 4a³ + 27b² ≠ 0 (mod p)
     * 2. Generator on curve: G satisfies curve equation
     * 3. Generator order: nG = ∞
     * 4. Cofactor validity: h·n = #E(F_p) (approximated via Hasse)
     *
     * @throws {Error} If validation fails
     */
    validate() {
        // Check non-singularity
        if (!ECMathUtils.validateCurveParameters(this)) {
            throw new Error(`Curve ${this.name} is singular (invalid parameters)`);
        }

        // Check generator is on curve
        if (!ECMathUtils.isOnCurve(this.G)) {
            throw new Error(`Generator point not on curve ${this.name}`);
        }

        // Check nG = ∞ (generator has correct order)
        const nG = ECMathUtils.scalarMultiply(this.n, this.G);
        if (!nG.isInfinity) {
            throw new Error(`Generator order incorrect for curve ${this.name}`);
        }

        // Verify n is prime (basic check for small n)
        // For cryptographic curves, we trust the standard parameters
        if (this.n < 1000000n) {
            // Simple primality check for educational small curves
            if (!this._isPrimeLikely(this.n)) {
                console.warn(`Order n may not be prime for curve ${this.name}`);
            }
        }
    }

    /**
     * Basic primality check (Miller-Rabin with few rounds)
     *
     * @private
     * @param {BigInt} n
     * @returns {Boolean}
     */
    _isPrimeLikely(n) {
        if (n < 2n) return false;
        return MathUtils.isDivisibleBySmallPrime(n);  // Assume prime for large n (trust standards)
    }

    /**
     * Get curve information for display
     *
     * @returns {Object}
     */
    getInfo() {
        return {
            name: this.name,
            equation: `y² = x³ + ${this.a}x + ${this.b} (mod p)`,
            fieldSize: ECMathUtils.bitLength(this.p),
            groupOrder: ECMathUtils.bitLength(this.n),
            cofactor: this.h.toString(),
            generator: {
                x: this.G.x.toString(16),
                y: this.G.y.toString(16)
            }
        };
    }
}

// ============================================================================
// STANDARD CURVE DEFINITIONS
// ============================================================================

/**
 * secp256k1 - Bitcoin and Ethereum Curve
 *
 * SPECIFICATION: SEC 2 (Standards for Efficient Cryptography)
 *
 * PROPERTIES:
 * - Koblitz curve (a = 0, efficient arithmetic)
 * - Prime-order group (h = 1)
 * - 256-bit security level
 *
 * CURVE EQUATION: y² = x³ + 7 (mod p)
 *
 * USAGE:
 * - Bitcoin (ECDSA signatures for transactions)
 * - Ethereum (account addresses, transaction signing)
 * - Many cryptocurrencies
 *
 * WHY CHOSEN BY BITCOIN:
 * - Fast (a = 0 simplifies operations)
 * - No NSA involvement (unlike NIST curves)
 * - Well-studied since 2000
 */
const secp256k1 = new EllipticCurve(
    'secp256k1',

    // p = 2^256 - 2^32 - 977 (Solinas prime for fast reduction)
    BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F'),

    // a = 0 (Koblitz curve)
    0n,

    // b = 7
    7n,

    // Generator G (uncompressed)
    {
        x: BigInt('0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'),
        y: BigInt('0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8')
    },

    // n = order of G (prime)
    BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'),

    // h = 1 (prime-order curve, no small subgroups)
    1n
);

/**
 * P-256 (secp256r1) - NIST Standard Curve
 *
 * SPECIFICATION: FIPS 186-4, SEC 2
 *
 * PROPERTIES:
 * - Random curve (a, b chosen pseudorandomly)
 * - Prime-order group (h = 1)
 * - 128-bit security level (256-bit keys)
 *
 * CURVE EQUATION: y² = x³ - 3x + b (mod p)
 *
 * USAGE:
 * - TLS/SSL (ECDHE-ECDSA cipher suites)
 * - U.S. government (NSA Suite B)
 * - Digital certificates (ECDSA signatures)
 *
 * CONTROVERSY:
 * - Parameters chosen by NSA (some distrust)
 * - Potentially backdoored (unproven conspiracy theory)
 * - Still widely used and considered secure
 */
const P256 = new EllipticCurve(
    'P-256',

    // p = 2^256 - 2^224 + 2^192 + 2^96 - 1 (Generalized Mersenne prime)
    BigInt('0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF'),

    // a = -3 (chosen for efficient arithmetic)
    BigInt('0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC'),

    // b (verifiably pseudorandom from seed)
    BigInt('0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B'),

    // Generator G
    {
        x: BigInt('0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296'),
        y: BigInt('0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5')
    },

    // n = order of G
    BigInt('0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551'),

    // h = 1
    1n
);

/**
 * Curve registry (for lookup by name)
 */
const CURVES = {
    'secp256k1': secp256k1,
    'P-256': P256,
    'P256': P256,  // Alias
    'secp256r1': P256  // Alias
};

/**
 * Get curve by name
 *
 * @param {String} name - Curve name
 * @returns {EllipticCurve|null}
 */
function getCurve(name) {
    return CURVES[name] || null;
}

// ============================================================================
// ECDH (ELLIPTIC CURVE DIFFIE-HELLMAN)
// ============================================================================

/**
 * Elliptic Curve Diffie-Hellman Key Exchange
 *
 * PROTOCOL:
 * 1. Alice generates private key dₐ ∈ [1, n-1]
 * 2. Alice computes public key Qₐ = dₐG
 * 3. Bob generates private key d_b ∈ [1, n-1]
 * 4. Bob computes public key Q_b = d_bG
 * 5. Alice computes shared secret S = dₐQ_b = dₐ(d_bG)
 * 6. Bob computes shared secret S = d_bQₐ = d_b(dₐG)
 * 7. Both have S = dₐd_bG (same point)
 *
 * SECURITY:
 * Based on Computational Diffie-Hellman (CDH) assumption:
 * Given G, aG, bG, computing abG is hard
 *
 * PASSIVE ADVERSARY:
 * Sees: G, Qₐ = dₐG, Q_b = d_bG
 * Cannot compute: S = dₐd_bG (requires solving ECDLP)
 *
 * ACTIVE ADVERSARY (MitM):
 * Can impersonate parties if no authentication
 * Solution: Use authenticated ECDH (sign public keys)
 *
 * KEY DERIVATION:
 * Raw shared secret should not be used directly
 * Use KDF (e.g., HKDF-SHA256) to derive session keys
 */
class ECDH {
    /**
     * @param {EllipticCurve} curve
     */
    constructor(curve) {
        this.curve = curve;
    }

    /**
     * Generate ECDH key pair
     *
     * PROCESS:
     * 1. Generate random private key d ∈ [1, n-1]
     * 2. Compute public key Q = dG
     *
     * SECURITY:
     * - Private key must be cryptographically random
     * - Never reuse private keys across protocols
     * - Store private key securely (hardware if possible)
     *
     * @returns {Object} - {privateKey: BigInt, publicKey: Point}
     */
    generateKeyPair() {
        // Generate random private key in [1, n-1]
        const privateKey = ECMathUtils.randomBigIntRange(1n, this.curve.n);

        // Compute public key Q = dG
        const publicKey = ECMathUtils.scalarMultiplySecure(privateKey, this.curve.G);

        // Validate public key is on curve (sanity check)
        if (!ECMathUtils.isOnCurve(publicKey)) {
            throw new Error('Generated public key not on curve (implementation error)');
        }

        return {
            privateKey,
            publicKey
        };
    }

    /**
     * Compute shared secret
     *
     * COMPUTATION: S = d × Q_other
     *
     * VALIDATION:
     * 1. Check Q_other is on curve (invalid curve attack)
     * 2. Check Q_other ≠ ∞ (degenerate case)
     * 3. Check Q_other is in correct subgroup (small subgroup attack)
     *
     * SECURITY CRITICAL:
     * Without validation, attacker can choose malicious Q_other
     * to leak bits of private key d
     *
     * @param {BigInt} privateKey - Our private key
     * @param {Point} otherPublicKey - Their public key
     * @returns {Point} - Shared secret point
     */
    computeSharedSecret(privateKey, otherPublicKey) {
        // Validate other party's public key
        this.validatePublicKey(otherPublicKey);

        // Compute shared secret S = d × Q_other
        const sharedSecret = ECMathUtils.scalarMultiplySecure(privateKey, otherPublicKey);

        // Verify result is not identity (degenerate case)
        if (sharedSecret.isInfinity) {
            throw new Error('Shared secret is point at infinity (invalid input)');
        }

        return sharedSecret;
    }

    /**
     * Validate received public key
     *
     * CHECKS:
     * 1. Point is on curve
     * 2. Point is not identity (∞)
     * 3. Point is in correct subgroup (order check)
     *
     * SECURITY:
     * Prevents invalid curve attacks and small subgroup attacks
     *
     * @param {Point} publicKey
     * @throws {Error} If validation fails
     */
    validatePublicKey(publicKey) {
        // Check 1: Point is on curve
        if (!ECMathUtils.isOnCurve(publicKey)) {
            throw new Error('Public key not on curve');
        }

        // Check 2: Point is not identity
        if (publicKey.isInfinity) {
            throw new Error('Public key is point at infinity');
        }

        // Check 3: Point is in correct subgroup
        // Verify n × Q = ∞ (Q has order dividing n)
        const nQ = ECMathUtils.scalarMultiply(this.curve.n, publicKey);
        if (!nQ.isInfinity) {
            throw new Error('Public key not in correct subgroup');
        }
    }

    /**
     * Derive session key from shared secret
     *
     * PROCESS:
     * Use hash function to derive key from x-coordinate
     * (Standard practice: only x-coordinate contributes to entropy)
     *
     * KEY DERIVATION FUNCTION (KDF):
     * sessionKey = H(x || label || context)
     *
     * NOTE: For production, use HKDF (HMAC-based KDF) per RFC 5869
     * Here we use simple hash for educational clarity
     *
     * @param {Point} sharedSecret
     * @param {String} label - Protocol label (e.g., "ECDH-AES")
     * @returns {Promise<String>} - Derived key (hex)
     */
    async deriveKey(sharedSecret, label = 'ECDH') {
        // Extract x-coordinate as entropy source
        const x = sharedSecret.x.toString(16).padStart(64, '0');

        // Combine with label for domain separation
        const input = x + label;

        // Hash to derive key (using SHA-256)
        const encoder = new TextEncoder();
        const data = encoder.encode(input);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);

        // Convert to hex string
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

        return hashHex;
    }
}

// ============================================================================
// ECDSA (ELLIPTIC CURVE DIGITAL SIGNATURE ALGORITHM)
// ============================================================================

/**
 * Elliptic Curve Digital Signature Algorithm
 *
 * PURPOSE: Digital signatures for authentication and non-repudiation
 *
 * SIGNING PROCESS:
 * 1. Hash message: h = H(m)
 * 2. Generate ephemeral key k ∈ [1, n-1] (MUST be random and unique!)
 * 3. Compute R = kG, r = R.x mod n
 * 4. Compute s = k⁻¹(h + r·d) mod n
 * 5. Signature is (r, s)
 *
 * VERIFICATION PROCESS:
 * 1. Hash message: h = H(m)
 * 2. Compute w = s⁻¹ mod n
 * 3. Compute u₁ = h·w mod n, u₂ = r·w mod n
 * 4. Compute R' = u₁G + u₂Q
 * 5. Accept if R'.x ≡ r (mod n)
 *
 * SECURITY:
 * Based on ECDLP + hash function collision resistance
 *
 * CRITICAL: k-nonce must be:
 * - Truly random (unpredictable)
 * - Unique for each signature
 * - Never revealed or reused
 *
 * CATASTROPHIC FAILURE MODES:
 * - Reused k: Attacker recovers private key from two signatures
 * - Biased k: Lattice attacks can recover private key
 * - Known k: Immediate private key recovery
 *
 * SOLUTION: RFC 6979 (Deterministic ECDSA)
 * Generate k = HMAC_DRBG(privateKey, hash(message))
 * - Deterministic (same message → same signature)
 * - Unpredictable without private key
 * - No need for high-quality randomness
 */
class ECDSA {
    /**
     * @param {EllipticCurve} curve
     */
    constructor(curve) {
        this.curve = curve;
    }

    /**
     * Generate ECDSA key pair
     *
     * Same as ECDH key generation:
     * - Private key: d ∈ [1, n-1]
     * - Public key: Q = dG
     *
     * @returns {Object} - {privateKey: BigInt, publicKey: Point}
     */
    generateKeyPair() {
        const ecdh = new ECDH(this.curve);
        return ecdh.generateKeyPair();
    }

    /**
     * Sign message
     *
     * ALGORITHM:
     * 1. Hash message: h = H(m)
     * 2. Generate k deterministically (RFC 6979)
     * 3. Compute R = kG, r = R.x mod n
     * 4. If r = 0, regenerate k (extremely rare)
     * 5. Compute s = k⁻¹(h + r·d) mod n
     * 6. If s = 0, regenerate k (extremely rare)
     * 7. Return signature (r, s)
     *
     * @param {String} message - Message to sign
     * @param {BigInt} privateKey - Private key d
     * @returns {Promise<Object>} - Signature {r: BigInt, s: BigInt}
     */
    async sign(message, privateKey) {
        // Step 1: Hash message
        const h = await this._hashMessage(message);

        // Step 2: Generate deterministic k (RFC 6979 simplified)
        // For production: Use full RFC 6979 HMAC_DRBG
        // For education: Use HMAC(privateKey, h) as k
        const k = await this._generateNonce(privateKey, h);

        // Step 3: Compute R = kG
        const R = ECMathUtils.scalarMultiplySecure(k, this.curve.G);
        const r = R.x % this.curve.n;

        // Check r ≠ 0 (negligible probability)
        if (r === 0n) {
            throw new Error('Signature generation failed: r = 0 (regenerate k)');
        }

        // Step 4: Compute s = k⁻¹(h + r·d) mod n
        const kInv = ECMathUtils.modInv(k, this.curve.n);
        if (kInv === null) {
            throw new Error('Failed to compute k⁻¹ (implementation error)');
        }

        const rd = ECMathUtils.modMul(r, privateKey, this.curve.n);
        const h_plus_rd = ECMathUtils.modAdd(h, rd, this.curve.n);
        const s = ECMathUtils.modMul(kInv, h_plus_rd, this.curve.n);

        // Check s ≠ 0 (negligible probability)
        if (s === 0n) {
            throw new Error('Signature generation failed: s = 0 (regenerate k)');
        }

        return { r, s };
    }

    /**
     * Verify signature
     *
     * ALGORITHM:
     * 1. Check signature validity: 1 ≤ r, s < n
     * 2. Hash message: h = H(m)
     * 3. Compute w = s⁻¹ mod n
     * 4. Compute u₁ = h·w mod n
     * 5. Compute u₂ = r·w mod n
     * 6. Compute R' = u₁G + u₂Q
     * 7. Accept if R'.x ≡ r (mod n)
     *
     * CORRECTNESS:
     * R' = u₁G + u₂Q
     *    = (h·w)G + (r·w)Q
     *    = (h·w)G + (r·w)(dG)
     *    = w(h + rd)G
     *    = s⁻¹(h + rd)G
     *    = kG  [since s = k⁻¹(h + rd)]
     *    = R
     *
     * @param {String} message
     * @param {Object} signature - {r, s}
     * @param {Point} publicKey - Q
     * @returns {Promise<Boolean>} - True if valid
     */
    async verify(message, signature, publicKey) {
        const { r, s } = signature;
        const n = this.curve.n;

        // Step 1: Validate signature components
        if (r < 1n || r >= n || s < 1n || s >= n) {
            return false;
        }

        // Validate public key
        try {
            const ecdh = new ECDH(this.curve);
            ecdh.validatePublicKey(publicKey);
        } catch (e) {
            return false;
        }

        // Step 2: Hash message
        const h = await this._hashMessage(message);

        // Step 3: Compute w = s⁻¹ mod n
        const w = ECMathUtils.modInv(s, n);
        if (w === null) {
            return false;
        }

        // Step 4: Compute u₁ = h·w mod n
        const u1 = ECMathUtils.modMul(h, w, n);

        // Step 5: Compute u₂ = r·w mod n
        const u2 = ECMathUtils.modMul(r, w, n);

        // Step 6: Compute R' = u₁G + u₂Q
        const u1G = ECMathUtils.scalarMultiplySecure(u1, this.curve.G);
        const u2Q = ECMathUtils.scalarMultiplySecure(u2, publicKey);
        const Rprime = ECMathUtils.pointAdd(u1G, u2Q);

        // Check if R' is point at infinity (invalid)
        if (Rprime.isInfinity) {
            return false;
        }

        // Step 7: Accept if R'.x ≡ r (mod n)
        const v = Rprime.x % n;
        return v === r;
    }

    /**
     * Hash message to integer in [0, n-1]
     *
     * PROCESS:
     * 1. Compute h = SHA-256(message)
     * 2. Convert to integer (big-endian)
     * 3. Reduce modulo n if necessary
     *
     * @private
     * @param {String} message
     * @returns {Promise<BigInt>}
     */
    async _hashMessage(message) {
        const encoder = new TextEncoder();
        const data = encoder.encode(message);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);

        // Convert hash to BigInt
        const hashArray = new Uint8Array(hashBuffer);
        let h = 0n;
        for (let i = 0; i < hashArray.length; i++) {
            h = (h << 8n) | BigInt(hashArray[i]);
        }

        // Reduce modulo n (usually not necessary as hash < n for 256-bit curves)
        return h % this.curve.n;
    }

    /**
     * Generate deterministic nonce (simplified RFC 6979)
     *
     * FULL RFC 6979:
     * Uses HMAC_DRBG with private key and hash as inputs
     *
     * SIMPLIFIED VERSION (educational):
     * k = HMAC-SHA256(privateKey, hash) mod n
     *
     * SECURITY:
     * - Deterministic: Same message → same k
     * - Unpredictable: Requires knowledge of private key
     * - Unique: Different messages → different k
     *
     * @private
     * @param {BigInt} privateKey
     * @param {BigInt} messageHash
     * @returns {Promise<BigInt>}
     */
    async _generateNonce(privateKey, messageHash) {
        // Convert inputs to byte arrays
        const keyBytes = this._bigIntToBytes(privateKey);
        const hashBytes = this._bigIntToBytes(messageHash);

        // Concatenate for HMAC input
        const combined = new Uint8Array(keyBytes.length + hashBytes.length);
        combined.set(keyBytes, 0);
        combined.set(hashBytes, keyBytes.length);

        // Import key for HMAC
        const hmacKey = await crypto.subtle.importKey(
            'raw',
            keyBytes,
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );

        // Compute HMAC
        const signature = await crypto.subtle.sign('HMAC', hmacKey, combined);

        // Convert to BigInt
        const sigArray = new Uint8Array(signature);
        let k = 0n;
        for (let i = 0; i < sigArray.length; i++) {
            k = (k << 8n) | BigInt(sigArray[i]);
        }

        // Ensure k ∈ [1, n-1]
        k = k % this.curve.n;
        if (k === 0n) k = 1n;

        return k;
    }

    /**
     * Convert BigInt to byte array
     *
     * @private
     * @param {BigInt} n
     * @returns {Uint8Array}
     */
    _bigIntToBytes(n) {
        const hex = n.toString(16).padStart(64, '0');
        const bytes = new Uint8Array(32);
        for (let i = 0; i < 32; i++) {
            bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return bytes;
    }
}

// Create the global namespace object
const ECCore = {
    // Core classes
    EllipticCurve,
    ECDH,
    ECDSA,

    // Standard curves (instances)
    secp256k1,
    P256,

    // Utility functions
    getCurve,

    // Mathematical utilities (assuming imported)
    ECMathUtils
};

// Make available globally for browser
if (typeof window !== 'undefined') {
    window.ECCore = ECCore;
}
